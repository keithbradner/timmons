<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Develop Like Dever - Exhibition</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;0,700;1,400&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #050505;
            color: #e0e0e0;
            font-family: 'Playfair Display', serif;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            user-select: none;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            background: radial-gradient(circle, transparent 40%, #000 120%);
        }
        
        /* Film Grain Effect */
        .grain {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 4;
            opacity: 0.04;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        /* Museum Placard Style */
        .panel {
            background: rgba(15, 15, 15, 0.92);
            border-top: 2px solid #555;
            border-bottom: 2px solid #555;
            box-shadow: 0 20px 50px rgba(0,0,0,0.95);
            padding: 40px 30px;
            margin: 20px auto;
            border-radius: 4px;
            pointer-events: auto;
            width: 85%;
            max-width: 600px;
            text-align: center;
            backdrop-filter: blur(12px);
            transition: opacity 0.6s ease, transform 0.6s ease;
        }

        h1 {
            margin: 0 0 15px 0;
            font-size: 2.2rem;
            color: #fff;
            letter-spacing: 1px;
            font-weight: 700;
            text-transform: uppercase;
        }

        p {
            font-family: 'Roboto Mono', monospace;
            font-size: 1rem;
            line-height: 1.6;
            color: #bbb;
            margin-bottom: 30px;
            text-align: left;
        }

        strong { color: #fff; }

        button {
            background: transparent;
            color: #fff;
            border: 2px solid rgba(255,255,255,0.3);
            padding: 18px 36px;
            font-family: 'Roboto Mono', monospace;
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.25s ease;
            width: 100%;
        }

        button:hover {
            background: #fff;
            color: #000;
            border-color: #fff;
        }
        
        button:disabled {
            opacity: 0.4;
            cursor: default;
            border-color: #444;
            color: #555;
        }
        
        button:disabled:hover { background: transparent; color: #555; }

        .hud-top {
            padding: 40px 20px;
            text-align: center;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .status-text {
            font-family: 'Roboto Mono', monospace;
            font-size: 1rem;
            color: #888;
            letter-spacing: 3px;
            text-transform: uppercase;
            background: rgba(0,0,0,0.8);
            padding: 8px 16px;
            border-radius: 20px;
            border: 1px solid #333;
        }

        /* Legacy timer display hidden in favor of 3D timer */
        .timer-display {
            display: none;
        }

        /* Action Bar for Portrait Mobile/Kiosk */
        #action-bar {
            position: absolute;
            bottom: 40px;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            pointer-events: auto;
        }

        .action-btn {
            background: rgba(10, 10, 10, 0.9);
            border: 1px solid #666;
            width: 85%;
            max-width: 500px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            padding: 20px;
        }

        .btn-inspect { border-color: #ffd700; color: #ffd700; }
        .btn-inspect:hover { background: #ffd700; color: #000; border-color: #ffd700; }

        .btn-resume { border-color: #ff4444; color: #ff4444; }
        .btn-resume:hover { background: #ff4444; color: #fff; border-color: #ff4444; }

        .btn-finish { border-color: #4CAF50; color: #4CAF50; }
        .btn-finish:hover { background: #4CAF50; color: #fff; border-color: #4CAF50; }

        .hidden {
            display: none !important;
            opacity: 0;
            pointer-events: none;
        }

        .film-review-text {
            text-align: left;
            font-size: 0.95rem;
            color: #ccc;
            margin-top: 20px;
            border-top: 1px solid #444;
            padding-top: 20px;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            border-bottom: 1px dashed #333;
            padding-bottom: 4px;
        }
        
        .stat-label { color: #888; text-transform: uppercase; font-size: 0.8rem; }
        .stat-val { color: #fff; font-weight: bold; }
        
        #verdict-text {
            font-family: 'Playfair Display', serif;
            font-size: 1.5rem;
            color: #fff;
            margin-top: 15px;
            text-align: center;
            font-style: italic;
        }

    </style>
</head>
<body>

    <div id="canvas-container"></div>
    <div class="overlay"></div>
    <div class="grain"></div>

    <div id="ui-layer">
        
        <div class="hud-top">
            <div id="mode-indicator" class="status-text">EXHIBIT READY</div>
        </div>

        <!-- Intro Panel -->
        <div id="panel-intro" class="panel">
            <h1>The Art of Control</h1>
            <p><strong>Dever Timmons</strong> was known for refusing "set-and-forget" processing. In the 1930s he adopted a German inspection method: a <strong>desensitizing bath</strong>, then <strong>inspection during development</strong> under a specially designed safelight, stopping each negative at the exact moment it reached the right contrast.</p>
            <p><strong>Note:</strong> Most camera films of the period were <strong>panchromatic</strong>, meaning they must be handled in <strong>total darkness</strong>. The room will dim to near-black during development. When you "inspect," a <strong>very dim green/yellow-green inspection safelight</strong> appears briefly—just long enough to judge the negative.</p>
            <button onclick="startGame()">Enter The Darkroom</button>
        </div>

        <!-- Phase 1 Intro -->
        <div id="panel-phase1" class="panel hidden">
            <h1>Phase 1: The Machine Method</h1>
            <p>Commercial processing relies on standard time-and-temperature routines. Sheet film is lowered into tanks (or trays) on a schedule, agitated the same way, and pulled when the timer says so.</p>
            <p>We will process a batch of 5 images on one fixed timetable. You will have <strong>zero control</strong> over individual outcomes.</p>
            <button onclick="preparePhase1()">Load Commercial Tank</button>
        </div>
        
        <!-- Action Bar (Shared) -->
        <div id="action-bar" class="hidden">
            <!-- Phase 1 Buttons -->
            <button id="p1-drop-btn" class="action-btn" onclick="triggerPhase1Action()">SUBMERGE FILM BATCH</button>
            
            <!-- Phase 2 Buttons -->
            <button id="p2-start-btn" class="action-btn hidden" onclick="triggerP2Start()">START PROCESS</button>
            <button id="p2-inspect-btn" class="action-btn btn-inspect hidden" onclick="triggerP2Inspect()">LIFT & INSPECT</button>
            
            <button id="p2-resume-btn" class="action-btn btn-resume hidden" onclick="triggerP2Resume()">RETURN TO TRAY</button>
            <button id="p2-finish-btn" class="action-btn btn-finish hidden" onclick="triggerP2Finish()">STOP BATH</button>
        </div>

        <!-- Phase 1 Results -->
        <div id="panel-result1" class="panel hidden">
            <h1>The Problem with Blindness</h1>
            <div class="film-review-text">
                <p>Observe the results. Because every sheet received the same time:<br><br>
                • <strong>Underexposed</strong> negatives remain thin and ghostly.<br>
                • <strong>Overexposed</strong> negatives are dense and blocked up.<br>
                • Only the "average" shots survived.</p>
            </div>
            <p>To create art, we must see what we are doing. We must use the <strong>Timmons Method</strong>.</p>
            <button onclick="setupPhase2()">Setup Inspection Trays</button>
        </div>

        <!-- Phase 2 Intro -->
        <div id="panel-phase2" class="panel hidden">
            <h1>Phase 2: The Artist's Eye</h1>
            <p>We will now process photos individually using Timmons' technique.</p>
            <p><strong>1. Desensitize (Forebath):</strong> Dip the sheet in <em>Pinakryptol Green</em> in darkness. This reduces sensitivity so the negative can be checked under a special inspection safelight.</p>
            <p><strong>2. Develop (Dark):</strong> Transfer to the developer tray in near-total darkness.</p>
            <p><strong>3. Inspect (10 seconds):</strong> Briefly lift the sheet to a <strong>dim yellow-green / dark-green safelight</strong> to judge highlight density. Return it to the developer if it's too pale.</p>
            <p><strong>4. Stop & Secure:</strong> When it's right, dunk it in a <strong>short stop bath</strong>. In a real darkroom it would then go to <strong>fixer</strong> and wash.</p>
            <button onclick="startPhase2()">Begin Inspection</button>
        </div>

        <!-- Final Results -->
        <div id="panel-final" class="panel hidden">
            <h1>A Masterpiece Created</h1>
            <p>By inspecting the development, you compensated for exposure errors in real-time. Shadows were preserved, and highlights were saved.</p>
            <div class="film-review-text">
                 <div class="stat-row"><span class="stat-label">Total Sheets</span> <span class="stat-val">5</span></div>
                 <div class="stat-row"><span class="stat-label">Technique</span> <span class="stat-val">Visual Inspection</span></div>
                 <div class="stat-row"><span class="stat-label">Quality Score</span> <span class="stat-val" id="final-score-val">0%</span></div>
                 <div id="verdict-text"></div>
            </div>
            <br>
            <button onclick="window.location.reload()">Reset Exhibit</button>
        </div>

    </div>

    <script>
        // --- THREE.JS SETUP ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x050505, 20, 70);

        // Portrait Camera Setup (9:16 optimized)
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 36, 12); 
        camera.lookAt(0, 0, 4); 

        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.1;
        renderer.outputEncoding = THREE.sRGBEncoding;
        container.appendChild(renderer.domElement);

        // --- SCENE GEOMETRY ---
        const roomGeo = new THREE.BoxGeometry(40, 50, 80);
        const roomMat = new THREE.MeshStandardMaterial({ color: 0x151515, roughness: 0.8, side: THREE.BackSide });
        const room = new THREE.Mesh(roomGeo, roomMat);
        room.position.y = 10;
        scene.add(room);

        // Elongated Table
        const tableGeo = new THREE.PlaneGeometry(30, 70);
        const tableMat = new THREE.MeshStandardMaterial({ color: 0x2a1d15, roughness: 0.9, metalness: 0.1 });
        const table = new THREE.Mesh(tableGeo, tableMat);
        table.rotation.x = -Math.PI / 2;
        table.position.y = -2.1; 
        table.receiveShadow = true;
        scene.add(table);

        const ambientLight = new THREE.HemisphereLight(0x111111, 0x000000, 0.6);
        scene.add(ambientLight);

        // Main Spot (Safelight)
        const spotLight = new THREE.SpotLight(0xffffff, 4);
        spotLight.position.set(0, 35, 0); 
        spotLight.angle = Math.PI / 2.5;
        spotLight.penumbra = 0.5;
        spotLight.castShadow = true;
        spotLight.shadow.mapSize.width = 1024;
        spotLight.shadow.mapSize.height = 1024;
        scene.add(spotLight);

        // Safelight Fixture
        const lampGroup = new THREE.Group();
        const lampCone = new THREE.Mesh(new THREE.ConeGeometry(2, 4, 32, 1, true), new THREE.MeshStandardMaterial({ color: 0x111111, side: THREE.DoubleSide, metalness: 0.8 }));
        lampCone.position.y = 25;
        lampGroup.add(lampCone);
        const bulbMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.8, 16, 16), bulbMat);
        bulb.position.y = 24;
        lampGroup.add(bulb);
        scene.add(lampGroup);

        // --- LABEL HELPER ---
        function createLabel(text, subText) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 160;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(0,0,0,0)';
            ctx.fillRect(0, 0, 512, 160);
            
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = "rgba(0,0,0,0.8)";
            ctx.shadowBlur = 10;
            ctx.fillStyle = '#ffffff';

            ctx.font = 'bold 50px "Roboto Mono", monospace';
            ctx.fillText(text, 256, 50);
            
            if (subText) {
                ctx.font = 'italic 36px "Playfair Display", serif';
                ctx.fillStyle = '#cccccc';
                ctx.fillText(subText, 256, 100);
            }
            
            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, side: THREE.DoubleSide, depthTest: false });
            const geo = new THREE.PlaneGeometry(10, 3);
            const mesh = new THREE.Mesh(geo, mat);
            mesh.rotation.x = -Math.PI / 2.5;
            mesh.renderOrder = 999;
            return mesh;
        }

        // --- TIMER HELPER ---
        const timerCanvas = document.createElement('canvas');
        timerCanvas.width = 256;
        timerCanvas.height = 128;
        const timerCtx = timerCanvas.getContext('2d');
        const timerTex = new THREE.CanvasTexture(timerCanvas);
        let accumulatedTime = 0;

        function updateTimerTexture(seconds) {
            timerCtx.fillStyle = '#111'; // Dark box
            timerCtx.fillRect(0, 0, 256, 128);
            timerCtx.strokeStyle = '#333';
            timerCtx.lineWidth = 5;
            timerCtx.strokeRect(0,0,256,128);

            const min = Math.floor(seconds / 60);
            const sec = Math.floor(seconds % 60);
            const text = `${min < 10 ? '0'+min : min}:${sec < 10 ? '0'+sec : sec}`;

            timerCtx.font = 'bold 80px "Roboto Mono", monospace';
            // Use amber/orange for classic darkroom timer look
            timerCtx.fillStyle = '#ffaa55';
            timerCtx.textAlign = 'center';
            timerCtx.textBaseline = 'middle';
            timerCtx.shadowColor = "#ff8800";
            timerCtx.shadowBlur = 15;
            timerCtx.fillText(text, 128, 64);
            
            timerTex.needsUpdate = true;
        }
        updateTimerTexture(0);

        // Timer Mesh
        const timerGeo = new THREE.BoxGeometry(6, 1.5, 3);
        const timerMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
        const timerMesh = new THREE.Mesh(timerGeo, timerMat);
        timerMesh.position.set(12, -1.2, 5); // Right side of developer
        timerMesh.castShadow = true;
        scene.add(timerMesh);

        // The face of the timer
        const timerFaceGeo = new THREE.PlaneGeometry(5.5, 2.5);
        const timerFaceMat = new THREE.MeshBasicMaterial({ map: timerTex });
        const timerFace = new THREE.Mesh(timerFaceGeo, timerFaceMat);
        timerFace.rotation.x = -Math.PI / 2;
        timerFace.position.y = 0.76; 
        timerMesh.add(timerFace);


        // --- TRAYS ---
        function createTray(width, height, depth, labelText, chemText) {
            const grp = new THREE.Group();
            const trayMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.4, metalness: 0.3 });
            
            const base = new THREE.Mesh(new THREE.BoxGeometry(width, 0.2, depth), trayMat);
            base.position.y = -2.0;
            base.receiveShadow = true;
            grp.add(base);
            
            const thick = 0.2;
            const h = 1.5;
            const w1 = new THREE.Mesh(new THREE.BoxGeometry(width + thick*2, h, thick), trayMat); 
            w1.position.set(0, -1.35, -depth/2 - thick/2);
            const w2 = new THREE.Mesh(new THREE.BoxGeometry(width + thick*2, h, thick), trayMat); 
            w2.position.set(0, -1.35, depth/2 + thick/2);
            const w3 = new THREE.Mesh(new THREE.BoxGeometry(thick, h, depth), trayMat); 
            w3.position.set(width/2 + thick/2, -1.35, 0);
            const w4 = new THREE.Mesh(new THREE.BoxGeometry(thick, h, depth), trayMat); 
            w4.position.set(-width/2 - thick/2, -1.35, 0);
            
            [w1,w2,w3,w4].forEach(w => { w.castShadow = true; w.receiveShadow = true; grp.add(w); });

            if(labelText) {
                const lbl = createLabel(labelText, chemText);
                lbl.position.set(0, 0, -depth/2 - 2); 
                grp.add(lbl);
            }

            return grp;
        }

        // TRAY 1: Desensitizer
        const desensTray = createTray(16, 1.5, 12, "DESENSITIZER", "Pinakryptol Green");
        desensTray.position.set(0, 0, -8);
        desensTray.visible = false;
        scene.add(desensTray);

        // TRAY 2: Developer
        const devTray = createTray(16, 1.5, 12, "DEVELOPER", "Metol-Hydroquinone");
        devTray.position.set(0, 0, 0);
        scene.add(devTray);
        
        const devTrayTarget = new THREE.Vector3(0, 0, 0);
        const devLiquidTarget = new THREE.Vector3(0, -1.0, 0);

        // --- LIQUIDS ---
        const liquidGeo = new THREE.PlaneGeometry(15.8, 11.8, 64, 48);
        
        const devLiquidMat = new THREE.MeshPhysicalMaterial({ color: 0x221105, roughness: 0.05, transmission: 0.9, opacity: 0.95, transparent: true });
        const devLiquid = new THREE.Mesh(liquidGeo, devLiquidMat);
        devLiquid.rotation.x = -Math.PI / 2;
        devLiquid.position.set(0, -1.0, 0); 
        scene.add(devLiquid);

        const desensLiquidMat = new THREE.MeshPhysicalMaterial({ color: 0x051105, roughness: 0.05, transmission: 0.9, opacity: 0.85, transparent: true });
        const desensLiquid = new THREE.Mesh(liquidGeo, desensLiquidMat);
        desensLiquid.rotation.x = -Math.PI / 2;
        desensLiquid.position.set(0, -1.0, -8);
        desensLiquid.visible = false;
        scene.add(desensLiquid);

        // --- SHEETS GENERATION ---
        const loader = new THREE.TextureLoader();
        const sheets = [];
        const paperW = 5;
        const paperH = 6;

        // Photo data with different exposure characteristics
        // devRate: how fast it develops (higher = faster)
        // idealTime: target inspectionValue for perfect exposure (1.0 = normal)
        const photoData = [
            { src: 'images/photo1.jpg', devRate: 0.0006, idealTime: 1.0 },  // Normal exposure
            { src: 'images/photo2.jpg', devRate: 0.0012, idealTime: 0.85 }, // Overexposed - develops fast, stop early
            { src: 'images/photo3.jpg', devRate: 0.0004, idealTime: 1.15 }, // Underexposed - develops slow, needs more time
            { src: 'images/photo4.jpg', devRate: 0.0010, idealTime: 0.9 },  // Slightly overexposed
            { src: 'images/photo5.jpg', devRate: 0.0005, idealTime: 1.1 }   // Slightly underexposed
        ];

        for (let i = 0; i < 5; i++) {
            const sheetGroup = new THREE.Group();

            const paperGeo = new THREE.BoxGeometry(paperW, 0.02, paperH);
            const paperMat = new THREE.MeshStandardMaterial({ color: 0xe0e0e0, roughness: 0.9 });
            const paper = new THREE.Mesh(paperGeo, paperMat);
            paper.castShadow = true;
            sheetGroup.add(paper);

            const tex = loader.load(photoData[i].src);
            tex.encoding = THREE.sRGBEncoding;
            const photoMat = new THREE.MeshBasicMaterial({
                map: tex,
                transparent: true,
                opacity: 0,
                color: 0xffffff,
                polygonOffset: true,
                polygonOffsetFactor: -2
            });
            const photoGeo = new THREE.PlaneGeometry(paperW - 0.2, paperH - 0.2);
            const photo = new THREE.Mesh(photoGeo, photoMat);
            photo.rotation.x = -Math.PI / 2;
            photo.position.y = 0.02;
            sheetGroup.add(photo);

            const sheetObj = {
                group: sheetGroup,
                photoMat: photoMat,
                targetPos: new THREE.Vector3((Math.random()-0.5)*0.5, 5 - (i*0.1), -20),
                targetRot: new THREE.Vector3(0, 0, 0),
                developed: 0,
                devRate: photoData[i].devRate,
                idealTime: photoData[i].idealTime
            };

            sheetGroup.position.copy(sheetObj.targetPos);
            sheets.push(sheetObj);
            scene.add(sheetGroup);
        }

        // --- ANIMATION LOOP ---
        let clock = new THREE.Clock();
        let phase = 'IDLE'; 
        let currentSheetIndex = 0;
        let inspectionValue = 0;
        let lightTargetColor = new THREE.Color(1, 1, 1); // Default White
        let waterDisturbance = 0;

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            waterDisturbance *= 0.96; 

            // Timer Logic
            if (phase === 'BLIND_WAIT' || phase === 'P2_DEVELOPING') {
                accumulatedTime += delta;
                updateTimerTexture(accumulatedTime);
            }

            // Liquid Simulation
            const positions = liquidGeo.attributes.position;
            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const y = positions.getY(i);
                let z = Math.sin(x * 2.0 + time) * 0.02 + Math.cos(y * 1.5 + time) * 0.02;
                if (waterDisturbance > 0.01) {
                    const dist = Math.sqrt(x*x + y*y);
                    z += Math.sin(dist * 6 - time * 12) * waterDisturbance * Math.exp(-dist*0.5);
                }
                positions.setZ(i, z);
            }
            positions.needsUpdate = true;
            liquidGeo.computeVertexNormals();

            // Lerp Trays
            devTray.position.lerp(devTrayTarget, 0.05);
            devLiquid.position.lerp(devLiquidTarget, 0.05);
            timerMesh.position.z = devTray.position.z; // Timer moves with tray

            // Lerp Sheets
            sheets.forEach(s => {
                s.group.position.lerp(s.targetPos, 0.06);
                s.group.rotation.x = THREE.MathUtils.lerp(s.group.rotation.x, s.targetRot.x, 0.06);
                s.group.rotation.y = THREE.MathUtils.lerp(s.group.rotation.y, s.targetRot.y, 0.06);
                s.group.rotation.z = THREE.MathUtils.lerp(s.group.rotation.z, s.targetRot.z, 0.06);
            });

            // Lights
            spotLight.color.lerp(lightTargetColor, 0.05);
            bulbMat.color.copy(spotLight.color);

            // Development Logic
            if (phase === 'P2_DEVELOPING') {
                const s = sheets[currentSheetIndex];
                if (s) {
                    inspectionValue += s.devRate; // Use per-sheet development rate
                    s.photoMat.opacity = 0.08;
                    s.photoMat.color.setHex(0x1a0000);
                }
            } else if (phase === 'P2_INSPECTING') {
                const s = sheets[currentSheetIndex];
                if (s) {
                    if (inspectionValue <= 1.0) {
                        s.photoMat.opacity = inspectionValue;
                        s.photoMat.color.setHex(0xffffff);
                    } else {
                        const burn = (inspectionValue - 1.0) * 1.5;
                        const c = Math.max(0, 1 - burn);
                        s.photoMat.color.setRGB(c, c, c);
                        s.photoMat.opacity = 1.0;
                    }
                }
            }

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- UI & LOGIC ---

        const modeText = document.getElementById('mode-indicator');
        const actionBar = document.getElementById('action-bar');
        
        const p1Btn = document.getElementById('p1-drop-btn');
        const p2StartBtn = document.getElementById('p2-start-btn');
        const p2InspectBtn = document.getElementById('p2-inspect-btn');
        const p2ResumeBtn = document.getElementById('p2-resume-btn');
        const p2FinishBtn = document.getElementById('p2-finish-btn');
        
        function startGame() {
            document.getElementById('panel-intro').classList.add('hidden');
            document.getElementById('panel-phase1').classList.remove('hidden');
            modeText.innerText = "PHASE 1: BLIND PROCESSING";
            lightTargetColor.setRGB(1, 1, 1); 
        }

        function preparePhase1() {
            document.getElementById('panel-phase1').classList.add('hidden');
            actionBar.classList.remove('hidden');
            p1Btn.classList.remove('hidden');
            
            // Phase 1: Center Developer (Z=0)
            devTrayTarget.set(0, 0, 0);
            devLiquidTarget.set(0, -1.0, 0);
            desensTray.visible = false;
            desensLiquid.visible = false;
            
            sheets.forEach((s, i) => {
                s.targetPos.set(0, 5 + (i*0.2), -20);
                s.targetRot.set(0, 0, 0);
            });
        }

        function triggerPhase1Action() {
            if (phase !== 'IDLE') return; 
            p1Btn.disabled = true;
            p1Btn.innerText = "DEVELOPING IN DARKNESS...";
            phase = 'BLIND_WAIT';
            accumulatedTime = 0;
            updateTimerTexture(0); // Reset timer texture
            
            // Dim light for Blind Phase
            lightTargetColor.setRGB(0.08, 0.08, 0.08);

            // Drop into Centered Tray
            // Reduce spread to 6x4 to avoid clipping
            sheets.forEach(s => {
                const rx = (Math.random() - 0.5) * 6; 
                const rz = (Math.random() - 0.5) * 4; 
                const ry = Math.random() * 3.14 * 2; 
                s.targetPos.set(rx, -1.9, rz);
                s.targetRot.set(0, ry, 0);
            });
            
            waterDisturbance = 1.0; 

            // Hardcoded 5s wait for blind mode logic, then auto-lift
            setTimeout(() => {
                lightTargetColor.setRGB(1, 1, 1);
                phase = 'BLIND_DONE';
                actionBar.classList.add('hidden');

                // Lift to Review - ZIGZAG STAGGERED LAYOUT
                sheets.forEach((s, i) => {
                    const xOffset = (i % 2 === 0) ? -3.5 : 3.5;
                    const zOffset = -5 + (i * 3.5);

                    s.targetPos.set(xOffset, 4, zOffset);
                    s.targetRot.set(0.5, 0, (i % 2 === 0 ? -0.2 : 0.2));

                    const r = Math.random();
                    if(r < 0.3) { s.photoMat.opacity = 0.3; }
                    else if (r > 0.7) { s.photoMat.opacity = 1.0; s.photoMat.color.setHex(0x333333); }
                    else { s.photoMat.opacity = 0.8; }
                });

                setTimeout(() => {
                    document.getElementById('panel-result1').classList.remove('hidden');
                }, 1000);
            }, 5000);
        }

        function setupPhase2() {
            document.getElementById('panel-result1').classList.add('hidden');
            document.getElementById('panel-phase2').classList.remove('hidden');
            
            // Phase 2: Slide Developer Bottom (Z=8)
            devTrayTarget.set(0, 0, 8);
            devLiquidTarget.set(0, -1.0, 8);
            desensTray.visible = true;
            desensLiquid.visible = true;

            sheets.forEach((s, i) => {
                s.targetPos.set((Math.random()-0.5), 5 - (i*0.1), -20); 
                s.targetRot.set(0, 0, 0);
                s.photoMat.opacity = 0;
                s.photoMat.color.setHex(0xffffff);
            });
            
            modeText.innerText = "PHASE 2: INSPECTION";
            accumulatedTime = 0;
            updateTimerTexture(0);
        }

        function startPhase2() {
            document.getElementById('panel-phase2').classList.add('hidden');
            actionBar.classList.remove('hidden');
            p1Btn.classList.add('hidden');
            p2StartBtn.classList.remove('hidden');
            
            currentSheetIndex = 0;
            phase = 'P2_IDLE';
            p2StartBtn.innerText = "START SHEET 1";
        }

        function triggerP2Start() {
            p2StartBtn.classList.add('hidden');
            modeText.innerText = "STEP 1: DESENSITIZING";
            accumulatedTime = 0;
            updateTimerTexture(0);

            // Dim lights before handling film
            lightTargetColor.setRGB(0.08, 0.08, 0.08);

            const s = sheets[currentSheetIndex];

            // 1. Lift
            s.targetPos.set(0, 5, -14);
            
            setTimeout(() => {
                // 2. Drop Desensitizer (Top Z=-8)
                s.targetPos.set(0, -1.9, -8);
                waterDisturbance = 0.6; 
                
                setTimeout(() => {
                    // 3. Lift
                    s.targetPos.set(0, 5, -8);
                    modeText.innerText = "MOVING TO DEVELOPER...";
                    
                    setTimeout(() => {
                        // 4. Move Over
                        s.targetPos.set(0, 5, 8);
                        
                        setTimeout(() => {
                            // 5. Drop Developer (Bottom Z=8)
                            modeText.innerText = "STEP 2: DEVELOPING (DARKNESS)";
                            s.targetPos.set(0, -1.9, 8);
                            waterDisturbance = 0.8; 
                            
                            phase = 'P2_DEVELOPING';
                            inspectionValue = 0;
                            
                            p2InspectBtn.classList.remove('hidden');
                        }, 700);
                    }, 700);
                }, 1500); 
            }, 700);
        }

        function triggerP2Inspect() {
            p2InspectBtn.classList.add('hidden');
            phase = 'P2_INSPECTING';
            modeText.innerText = "INSPECTING (GREEN SAFE-LIGHT)";
            
            const s = sheets[currentSheetIndex];
            // Lift Center (Z=0)
            s.targetPos.set(0, 8, 0);
            s.targetRot.set(0.5, 0, 0); // Face Camera
            
            lightTargetColor.setRGB(0.1, 0.8, 0.2);
            
            p2ResumeBtn.classList.remove('hidden');
            p2FinishBtn.classList.remove('hidden');
        }

        function triggerP2Resume() {
            p2ResumeBtn.classList.add('hidden');
            p2FinishBtn.classList.add('hidden');
            
            phase = 'P2_DEVELOPING';
            modeText.innerText = "RESUMING DEVELOPMENT...";
            
            const s = sheets[currentSheetIndex];
            s.targetPos.set(0, -1.9, 8); 
            s.targetRot.set(0, 0, 0);
            
            waterDisturbance = 0.5;
            lightTargetColor.setRGB(0.08, 0.08, 0.08); 
            
            p2InspectBtn.classList.remove('hidden');
        }

        const scoreLog = [];

        function triggerP2Finish() {
            p2ResumeBtn.classList.add('hidden');
            p2FinishBtn.classList.add('hidden');
            
            const s = sheets[currentSheetIndex];
            let score = 0;
            const dist = Math.abs(s.idealTime - inspectionValue);
            if (dist < 0.15) score = 100;
            else if (dist < 0.3) score = 70;
            else score = 30; 
            scoreLog.push(score);

            // Move to Finish Stack (Bottom Far Z=20)
            s.targetPos.set((Math.random()-0.5), -2 + (currentSheetIndex*0.1), 20);
            s.targetRot.set(0, 0, 0);
            
            // Fix Final Appearance
            s.photoMat.color.setHex(0xffffff);
            if(inspectionValue > 1.2) s.photoMat.color.setHex(0x555555);
            s.photoMat.opacity = Math.min(inspectionValue, 1.0);

            currentSheetIndex++;
            if (currentSheetIndex >= 5) {
                endPhase2();
            } else {
                phase = 'P2_IDLE';
                modeText.innerText = "READY FOR NEXT";
                p2StartBtn.innerText = `START SHEET ${currentSheetIndex+1}`;
                p2StartBtn.classList.remove('hidden');
                
                lightTargetColor.setRGB(1, 1, 1); 
            }
        }

        function endPhase2() {
            phase = 'REVIEW';
            actionBar.classList.add('hidden');
            
            // Staggered vertical layout - tilt towards camera
            sheets.forEach((s, i) => {
                const xOffset = (i % 2 === 0) ? -3.5 : 3.5;
                const zOffset = -5 + (i * 3.5);
                s.targetPos.set(xOffset, 4, zOffset);
                s.targetRot.set(0.5, 0, (i%2===0 ? 0.1 : -0.1));
            });

            const total = scoreLog.reduce((a, b) => a + b, 0);
            const avg = Math.round(total / 5);
            let verdict = avg >= 90 ? "Master Pictorialist" : (avg >= 70 ? "Skilled Printer" : "Novice");

            document.getElementById('final-score-val').innerText = avg + "%";
            document.getElementById('verdict-text').innerText = verdict;
                
            modeText.innerText = "SESSION COMPLETE";
            
            setTimeout(() => {
                document.getElementById('panel-final').classList.remove('hidden');
            }, 1000);
        }
    </script>
</body>
</html>